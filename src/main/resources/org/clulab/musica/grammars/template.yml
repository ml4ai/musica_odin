vars:
  agents: "nsubj|'nsubj:xsubj'|'nsubjpass:xsubj'|nsubjpass|csubj|csubjpass|<acl"  #Comment:  nsubjpass for cause should not be there in an ideal world; but it does show up in practice
  conjunctions: "appos|conj|conj_|cc"
  complements: "xcomp|ccomp"
  adverbial_clause: "advcl"
  noun_modifiers: "amod|compound|dep|name"
  negTriggers: "not"
  objects: "dobj"
  preps: "nmod_of|nmod_in|nmod_to|nmod_over|nmod_for"
  prep_dobjs: "nmod"
  quant_modifiers: "amod|advmod"
  passive_agents: "nmod_by|nmod_agent|agent"
  location_preps: "nmod_at|nmod_in|nmod_on"
  # Todo: nmod_from "X will follow from Y"

rules:



#
# The rest of the rules here are PORTED FROM pos-reg_template.yml from REACH grammar
# NB: These rules are mostly the same as the pos-reg rules, except that all instances of "auxtriggers" in the pattern trigger have been deleted.
#

#  - name: ported_syntax_1_verb-${addlabel}
#    priority: ${ rulepriority }
#    #example: "The water quality caused an increase in poverty and a decrease in poverty."
#    example: "improved economic performance expected to cause a shift from agriculture to service industry."
#    label: ${ label }
#    pattern: |
#      trigger = [word=/(?i)^(${ trigger })/ & tag=/^V/] # original rule had RB as possible tag
#      # Previous -- removed the complements because they were over matching
#      cause: Entity = </${adverbial_clause}/? (${ agents }) /nmod_than|${ objects }|${ conjunctions }|${ noun_modifiers}/{,2} ([word=/(?i)^(${ trigger })/] /${ preps }/{,2})?
#      effect: Entity = prepc_by? (${objects} | ${complements}) /${ noun_modifiers }|${ preps }/{,2} ([word=/(?i)^(${ trigger })/] /${ preps }/{,2})?

## --------------------------------------------
              # Complexer Events
## --------------------------------------------

    # no "type" so it's a syntax rule
    # Covers common Insert, Delete, Reverse predicate syntax
    - name: ${addlabel}-active_voice-syntax-1
      label: ${label}
      priority: ${rulepriority}
      pattern: |
        trigger = [word=/(?i)^(${trigger})/]
        note: Note? = >dobj
        onset: Onset? = >dobj? >/(${location_preps})/

    # jc added
    # more common insert, delete, reverse predicate syntax
    - name: ${addlabel}-active_voice-syntax-2
      label: ${label}
      example: "Add an eighth note to the first measure"
      priority: ${rulepriority}
      pattern: |
        trigger = [word=/(?i)^${trigger}/]
        note: Note? = >dobj
        measure: Measure? = >/nmod_*/
        locationabs: Locationabs? = >/nmod_*/

#    - name: ${addlabel}-active_voice-syntax-3
#      label: ${label}
#      example: "drop a quarter note from the start of the second measure"
#      priority: ${rulepriority}
#      pattern: |
#        trigger = [word=/(?i)^${trigger}/]
#        note: Note = >dobj


    # jc added
    # todo: would using 'MusicalEntity' instead of note, pitch,rest be problematic in the framework?
    - name: ${addlabel}-passive_voice-syntax-1
      label: ${label}
      example: "An eighth note is added to the first measure"
      priority: ${rulepriority}
      pattern: |
        trigger = [word=/(?i)^${trigger}/]
        note: Note? = >nsubjpass
        pitch: Pitch? = >nsubjpass
        rest: Rest? = >nsubjpass
        locationabs: Locationabs? = >/nmod_*/
        locationrel: Locationrel? = >/nmod_*/

    # jc added
    - name: ${addlabel}-passive_voice-syntax-2
      label: ${label}
      example: "An eighth note is added to the first measure"
      priority: ${rulepriority}
      pattern: |
        trigger = [word=/(?i)^${trigger}/]
        note: Note? = >nsubjpass
        pitch: Pitch? = >nsubjpass
        rest: Rest? = >nsubjpass
        onset: Onset? = >/nmod_*/


    # jc added
    # more common insert, delete, reverse predicate syntax
#    - name: ${addlabel}-active_voice-syntax-3
#      label: ${label}
#      example: "Add a quarter note to the start of measure 2"
#      priority: ${rulepriority}
#      pattern: |
#        trigger = [word=/(?i)^${trigger}/]
#        note: Note? = >dobj
#        locationabs: Locationabs? = >/nmod_*/
#      # measure: Measure? = >/nmod_*/ >nmod_of
#      # todo: better to attach measure to location-abs or trigger?

    # Useful for when the verb is tagged as an NN, and so we can't use the parse
    - name: ${addlabel}-active_voice-surface-1
      label: ${label}
      example: "Reverse all the notes in measure 1."
      priority: ${rulepriority}
      type: token
      pattern: |
        (?<trigger>[word=/(?i)^(${trigger})/]) @note:Note (that (are|is))? []{,2} @onset:Onset

    # jc added
    - name: ${addlabel}-passive_voice-surface-1
      label: ${label}
      example: "All the notes in measure 1 are reversed"
      priority: ${rulepriority}
      type: token
      pattern: |
        (@note:Note|@rest:Rest|@pitch:Pitch) []? (@onset:Onset)? []? [word=/^(${aux_be})/] (?<trigger>[word=/(?i)^(${trigger})/])


    #-------------------------------------------------------------
    #   Everything rules

    - name: ${addlabel}-active_voice-syntax-everything
      label: ${label}
      priority: ${rulepriority}
      pattern: |
        trigger = [word=/(?i)^(${trigger})/]
        specifier: Specifier = >dobj
        onset: Onset? = >dobj? >/(${location_preps})/

    # Useful for when the verb is tagged as an NN, and so we can't use the parse
    - name: ${addlabel}-active_voice-surface-everything
      label: ${label}
      example: "Reverse all the notes in measure 1."
      priority: ${rulepriority}
      type: token
      pattern: |
        (?<trigger>[word=/(?i)^(${trigger})/]) @specifier:Specifier (that (are|is))? []{,2} @onset:Onset